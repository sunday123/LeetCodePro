#### LRU缓存

https://leetcode-cn.com/problems/lru-cache-lcci/

```java
class LRUCache {
    int capacity;
    LinkedList<Integer>  linkList;
    Map<Integer,Integer> map;
    public LRUCache(int capacity) {
     this.capacity = capacity;
     linkList = new LinkedList <Integer>();
     map = new HashMap <Integer,Integer>();
    }

    public int get(int key) {
          if (linkList.contains(key)){
              int value = map.get(key);
              linkList.remove(linkList.indexOf(key));
              linkList.add(key);
              return value;
          }else {
              return -1;
          }
    }

    public void put(int key, int value) {
        if (linkList.contains(key)){
            linkList.remove(linkList.indexOf(key));
            linkList.addLast(key);
            map.put(key,value);

        }else {
            if (linkList.size()<capacity){
                linkList.addLast(key);
                map.put(key,value);
            }else {
                int oldKey = linkList.get(0);
                linkList.remove(linkList.indexOf(oldKey));
                map.remove(oldKey);
                linkList.addLast(key);
                map.put(key,value);
            }
        }
    }



}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

------



#### 46全排列

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

https://leetcode-cn.com/problems/permutations/

```java
class Solution {
    List<List<Integer>> results = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        LinkedList<Integer> result = new LinkedList<Integer>();
        backtrack(nums,result);
        return results;
    }

    public void backtrack(int[] nums,LinkedList<Integer> result){
        if(result.size() == nums.length) {
            results.add(new LinkedList(result));
            return;
        }

        for(int i=0;i<nums.length;i++){
            if(result.contains(nums[i])) continue;
            result.add(nums[i]);
            backtrack(nums,result);
            result.removeLast();
        }

    }



}
```

------

#### 78子集

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

https://leetcode-cn.com/problems/subsets/

```java
class Solution {
   List<List<Integer>> results = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        LinkedList<Integer> result = new LinkedList<Integer>();
       
        backtrack(nums,result,0);
        return results;
    }

    public void backtrack(int[] nums,LinkedList<Integer> result,int start){


        for(int i=start;i<nums.length;i++){
            result.add(nums[i]);
            backtrack(nums,result,i+1);
            result.removeLast();
        }
       results.add(new LinkedList(result));
    }
}
```

#### 24 两两交换链表中的节点

给定 1->2->3->4, 你应该返回 2->1->4->3.

https://leetcode-cn.com/problems/swap-nodes-in-pairs/



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
           return reverseKGroup(head,2);
    }

    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode temp = head;
//       先用temp找到3的位置，不足，就返回head不反转
        for(int i=1;i<k && temp!=null;i++){
            temp=temp.next;
        }
        if (temp == null) return head;
//        用t2记录记录4的位置，把三四断开
        ListNode  t2 = temp.next;
        temp.next=null;
//        反转前部分，头部设置为newHead，此时head在3的位置了
        ListNode newHead = reListNode(head);
//        把1-2-3与后面的连接起来，后面的继续递归：head.next=reverseKGroup(t2,k);
        head.next=reverseKGroup(t2,k);
        return newHead;
    }

    private ListNode reListNode(ListNode head){
        ListNode next=null;
        ListNode pre=null;
        while (head!=null){
            next=head.next;
            head.next=pre;
            pre=head;
            head=next;

        }
        return pre;
    }
}
```

#### 110. 平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

https://leetcode-cn.com/problems/balanced-binary-tree/

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
         if(root==null) return true;
         int l= getH(root.left);
         int r=getH(root.right);
         int abs =Math.abs(l-r);
         if(abs>1) return false;
         return isBalanced(root.left) && isBalanced(root.right);
    }
    public int getH(TreeNode root){
        if(root==null) return 0;
        int left = getH(root.left);
        int right = getH(root.right);
        int result = left>right?left+1:right+1;
        return result;
    }
}
```

